#region License

//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------

#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

#endregion

namespace OpenRasta.Tests.Unit.Authentication.Basic
{
    #region Using Directives

    using Moq;

    using NUnit.Framework;

    using OpenRasta.Authentication;
    using OpenRasta.Authentication.Basic;
    using OpenRasta.Contracts.Authentication.Basic;
    using OpenRasta.Hosting.InMemory;
    using OpenRasta.Testing.Specifications;

    #endregion

    [TestFixture]
    public class BasicAuthenticationScheme_Specification
    {
        Mock<IBasicAuthenticator> mockAuthenticator;
        InMemoryRequest request;
        BasicAuthenticationScheme basicScheme;

        [SetUp]
        public void BeforeEachTest()
        {
            this.mockAuthenticator = new Mock<IBasicAuthenticator>();
            this.request = new InMemoryRequest();
            this.basicScheme = new BasicAuthenticationScheme(this.mockAuthenticator.Object);
        }

        [TearDown]
        public void AfterEachTest()
        {
            this.mockAuthenticator.VerifyAll();
        }

        [Test]
        public void Given_AValidBasicAuthHeader_When_TheRequestIsAuthenticated_Then_TheResult_IsSuccess_And_UsernameIsSet_And_RolesAreSet()
        {
            // given
            string validAuthString = "Basic U2F1c2FnZTphbmQgbWFzaA==";
            string username = "Sausage";
            string password = "and mash";

            string[] userRoles = new[] { "Admin", "Manager", "Developer" };

            this.request.Headers["Authorization"] = validAuthString;

            this.mockAuthenticator
                .Expect(auth => auth.Authenticate(It.Is<BasicAuthRequestHeader>(h => h.Username == username && h.Password == password)))
                .Returns(new AuthenticationResult.Success(username, userRoles));

            // when
            var result = this.basicScheme.Authenticate(this.request);

            // then
            result.ShouldBeOfType<AuthenticationResult.Success>();
            var success = result as AuthenticationResult.Success;

            success.Username.ShouldBe(username);
            success.Roles.ShouldHaveSameElementsAs(userRoles);
        }

        [Test]
        public void Given_AMalformedBasicAuthHeader_When_TheRequestIsAuthenticated_Then_TheResult_IsMalformed()
        {
            // given
            string malformedAuthString = "Basic notAValidBase64String!!!";
            this.request.Headers["Authorization"] = malformedAuthString;

            // when
            var result = this.basicScheme.Authenticate(this.request);

            // then
            result.ShouldBeOfType<AuthenticationResult.MalformedCredentials>();
        }

        [Test]
        public void Given_ABasicAuthenticatorReturnsFailed_When_TheRequestIsAuthenticated_Then_TheResult_IsFailed()
        {
            // given
            string authString = "Basic U2F1c2FnZTphbmQgbWFzaA==";
            string username = "Sausage";
            string password = "and mash";

            this.request.Headers["Authorization"] = authString;

            this.mockAuthenticator
                .Expect(auth => auth.Authenticate(It.Is<BasicAuthRequestHeader>(h => h.Username == username && h.Password == password)))
                .Returns(new AuthenticationResult.Failed());

            // when
            var result = this.basicScheme.Authenticate(this.request);

            // then
            result.ShouldBeOfType<AuthenticationResult.Failed>();
        }

        [Test]
        public void Given_ABasicAuthenticatorWithARealm_When_ChallengingAResponse_Then_TheResponseHasAWWWAuthenticateHeader()
        {
            // given
            string realm = "Lex Luthors Palace";
            var response = new InMemoryResponse();

            this.mockAuthenticator
                .ExpectGet(auth => auth.Realm)
                .Returns(realm);

            // when
            this.basicScheme.Challenge(response);

            // then
            var expectedChallengeHeader = string.Format("Basic realm=\"{0}\"", realm);
            response.Headers.ShouldContain("WWW-Authenticate", expectedChallengeHeader);
        }
    }
}
