#region License

//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------

#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

#endregion

namespace OpenRasta.Tests.Unit.Codecs.CodecRepository
{
    #region Using Directives

    using System;
    using System.Linq;

    using NUnit.Framework;

    using OpenRasta.Codecs;
    using OpenRasta.Codecs.Framework;
    using OpenRasta.Contracts.Codecs;
    using OpenRasta.Contracts.TypeSystem;
    using OpenRasta.Testing.Specifications;
    using OpenRasta.TypeSystem;
    using OpenRasta.Web;

    #endregion

    public class codec_repository_context : context
    {
        private CodecMatch thenTheResultScoring;
        private readonly ITypeSystem typeSystem = TypeSystems.Default;

        public ICodecRepository Codecs { get; set; }

        public CodecRegistration ThenTheResult { get; set; }

        [SetUp]
        public void Setup()
        {
            this.Codecs = new CodecRepository();
            this.ThenTheResult = null;
        }

        protected void GivenACodec<TCodec, TResource>(string mediaTypes)
        {
            GivenACodec<TCodec, TResource>(mediaTypes, null);
        }

        protected void GivenACodec<TCodec, TResource>(string mediaTypes, string config)
        {
            foreach (var mediaType in MediaType.Parse(mediaTypes))
            {
                Type resourceType = typeof(TResource);

                this.Codecs.Add(
                    CodecRegistration.FromResourceType(
                        resourceType,
                        typeof(TCodec),
                        TypeSystems.Default,
                        mediaType,
                        null,
                        config, 
                        false));
            }
        }

        protected void WhenFindingCodec(string contentType, params Type[] resourcetypes)
        {
            this.ThenTheResult = null;
            this.thenTheResultScoring = null;
            this.thenTheResultScoring = this.Codecs.FindMediaTypeReader(new MediaType(contentType), resourcetypes.Select(x => (IMember)this.typeSystem.FromClr(x)), null);
            
            if (this.thenTheResultScoring == null)
            {
                return;
            }
            
            this.ThenTheResult = this.thenTheResultScoring.CodecRegistration;
        }
    }
}